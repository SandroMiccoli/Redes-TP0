%	Documentação do Trabalho Prático 1 de AEDSIII
%	@Sandro Miccoli
%
%	* Você pode identificar erros de grafia através do seguinte comando linux:
%		aspell --encoding="iso8859-1" -c -t=tex --lang="pt_BR" tp0.tex
%

\documentclass[12pt]{article}
\usepackage{sbc-template}
\usepackage{graphicx}
\usepackage{latexsym}
\usepackage{subfigure}
\usepackage{times,amsmath,epsfig}
\usepackage{graphicx,url}
 \makeatletter
 \newif\if@restonecol
 \makeatother
 \let\algorithm\relax
 \let\endalgorithm\relax
\graphicspath{{./data/}}
\usepackage[lined,algonl,ruled]{algorithm2e}
\usepackage{multirow}
\usepackage[brazil]{babel}
\usepackage[latin1]{inputenc}

\usepackage{alltt}
\renewcommand{\ttdefault}{txtt}

\sloppy

\title{REDES DE COMPUTADORES\\TRABALHO PRÁTICO 0: \\ Cálculo de CRC de um arquivo}

\author{Sandro Miccoli - 2009052409 - smiccoli@dcc.ufmg.br\\Leandro Duarte - 2009052271 - leandro.assis@dcc.ufmg.br}

\address{Departamento de Ciência da Computação -- Universidade Federal de Minas Gerais (UFMG)\\
\\
\today
}


\begin{document}

\maketitle

\begin{resumo}
Esse relatório descreve como foi implementado o algoritmo de detecção de erros conhecido como Cyclic Redundancy Check (CRC). Neste trabalho específico iremos utilizar polinômios geradores de 8 e 16 bits.

\end{resumo}

\section{INTRODUÇÃO}

	O CRC é uma técnica utilizada para detecção de erros de transmissão de dados digitais. As mensagens a serem transmitidas são tratadas como códigos polinomiais, sendo representada por uma série de binários.

	A cada bloco de dado transmitido é anexada um valor de checagem (\textit{check value}), que é baseado no resto de uma divisão polinomial entre o conteúdo dos dados e um polinômio gerador.
	Quandos esses dados são recebidos, é feito o mesmo cálculo e, caso os valores de checagem não coincidam, pode-se inferir que ocorreu um erro na propagação desses dados \cite{wiki}.

\section{MODELAGEM}
\label{modelagem}

O programa foi dividido em dois módulos, o primeiro (hex\_bin) responsável pela manipulação dos dados e conversão para binário e hexadecimal. O segundo (crc) para realizar o XOR entre dois bits e efeticamente calcular o CRC.

A seguir descreveremos os algoritmos e as principais funções e procedimentos implementados para o trabalho:

\subsection{Funções implementadas}

\vspace{0.2 true cm}

\begin{itemize}
 \item \begin{large}\textit{char xor (char a, char b)}\end{large}\\
 \subitem \textbf{Descrição:} Calcula a operação OU exclusivo entre os caracteres A e B recebidos por parametro.
 \subitem \textbf{Parâmetros:} Dois caracteres (a e b).
 \subitem \textbf{Complexidade:} $O(1)$, pois são realizadas apenas atribuições.
\end{itemize}

\vspace{0.2 true cm}

\begin{itemize}
 \item \begin{large}\textit{void CalculaCRC(char* bin, char* polinomio)}\end{large}\\
 \subitem \textbf{Descrição:} Calcula o CRC a partir de uma sequência de binários e do polinômio gerador.
 \subitem \textbf{Parâmetros:} Duas sequências de binários.
 \subitem \textbf{Complexidade:} $O(m*n)$, sendo m o tamanho do arquivo e n o tamanho do polinômio, pois possui dois laços aninhados, o externo que percorre toda a cadeia de bits do arquivo,
 e o interno que faz a operação bit a bit dos restos das divisões sucessivas com o polinômio.
.
\end{itemize}

\vspace{0.2 true cm}

\begin{itemize}
 \item \begin{large}\textit{char* ReadFile(char *name)}\end{large}\\
 \subitem \textbf{Descrição:} Lê todos os dados do arquivo e retorna seu conteúdo em um buffer.
 \subitem \textbf{Parâmetros:} Nome do arquivo.
 \subitem \textbf{Complexidade:} $O(n)$, sendo $n$ o tamanho do arquivo.
\end{itemize}

\vspace{0.2 true cm}

\begin{itemize}
 \item \begin{large}\textit{void BinToHex(char* bin, char *hex)}\end{large}\\
 \subitem \textbf{Descrição:} Converte binário para hexadecimal.
 \subitem \textbf{Parâmetros:} Sequência de bits e outro vetor para armazenar o resultado em hexadecimal.
 \subitem \textbf{Complexidade:} $O(n)$, sendo $n$ o tamanho da sequência de binários.
\end{itemize}

\vspace{0.2 true cm}

\begin{itemize}
 \item \begin{large}\textit{char * HexToBin(unsigned char c)}\end{large}\\
 \subitem \textbf{Descrição:} Converte hexadecimal para binário.
 \subitem \textbf{Parâmetros:} Caractere em hexadecimal.
 \subitem \textbf{Complexidade:} $O(1)$, pois é realizada apenas atribuições.
\end{itemize}

\vspace{0.2 true cm}

\begin{itemize}
 \item \begin{large}\textit{void ArquivoToBin(char * bin, char * arquivo))}\end{large}\\
 \subitem \textbf{Descrição:} Converte o conteúdo do arquivo para um vetor de binários.
 \subitem \textbf{Parâmetros:} Vetor de binário e vetor que contém o arquivo.
 \subitem \textbf{Complexidade:} $O(n)$, sendo $n$ o tamanho do arquivo.
\end{itemize}

\vspace{0.2 true cm}

\section{SOLUÇÃO PROPOSTA}
\label{solucao_proposta}

Para solucionar o problema do CRC, primeiro convertemos o arquivo de entrada em um array de binários, para podermos trabalhar com ele como vimos em sala de aula.

\subsection{DECISÕES DE IMPLEMENTAÇÃO}
\label{decisoes}

Para fins de cálculo do CRC, os caracteres de quebra de linha e fim de arquivo foram considerados como parte integrante do arquivo, por entendermos que os mesmos serão transmitidos conjuntamente ao conteúdo.

\section{IMPLEMENTAÇÃO}
\label{implementacao}

\subsection{Código}

\subsubsection{Arquivos .c}

\begin{itemize}
\item \textbf{main.c} Arquivo principal que aloca memória para os binários e faz as chamadas das funções de leitura do arquivo e cálculo do CRC.
\item \textbf{crc.c} Contém implementação da operação XOR e do CRC.
\item \textbf{hex\_bin.c} Contém funções de manipulação de sequências binárias, hexadecimais e conversão do arquivo para binário.
\end{itemize}

\subsubsection{Arquivos .h}

\begin{itemize}
\item \textbf{crc.h} Contém o cabeçalho da operação XOR e do CRC.
\item \textbf{hex\_bin.h} Contém o cabeçalho das funções de sequências binárias, hexadecimais e conversão do arquivo para binário.
\end{itemize}

\subsection{Compilação}

O programa deve ser compilado através do compilador GCC através de um makefile. Os modulos possiveis são:\\
\begin{itemize}
 \item ./make \\
Com este comando, o programa será compilado.
 \item ./make run\\
Com este comando, o programa irá rodar da seguinte maneira: ./crc arquivo.txt 0.
 \item ./make clean\\
Com este comando o executavel e outros arquivos desnecessários serão apagados.
\end{itemize}

\subsection{Execução}

A execução do programa tem como parâmetros:
\begin{itemize}
\item Um arquivo de entrada (texto ou binário)
\item Um índice do polinômio gerador, que pode ser 0 ou 1, para polinômios de 8 e 16 bits, respectivamente.
\end{itemize}

O comando para a execução do programa é da forma:

\begin{footnotesize}
\begin{verbatim} ./crc <arquivo binario de entrada> <índice do polinômio - 0 ou 1>\end{verbatim}
\end{footnotesize}


\section{AVALIAÇÃO EXPERIMENTAL}
\label{avaliacao_experimental}

Fizemos testes com arquivos no formato texto e binário. Um teste com arquivos pequenos e outro com arquivos razoávelmente grandes (alguns $mb$).\\
\\
\textbf{Teste realizado:} arquivo .txt com os caracteres 'tp', sem aspas, gerando 2 bytes + o byte de fim de arquivo.\\
\textbf{Binário de entrada:} 01110100011100000000101000000000\\
\textbf{Polinomio 0:} 100000111\\
\textbf{Resultado do CRC:} 01011000 = 0x58 em hex\\
\\
\textbf{Teste realizado:} arquivo .txt com milhares de caracteres, gerando 907349 bytes + o byte de fim de arquivo.\\
\textbf{Binário de entrada:} não o colocaremos aqui por causa do seu tamanho\\
\textbf{Polinomio 1:} 0101010110110111\\
\textbf{Resultado do CRC:} 0111011000110110 = 0x7636 em hex\\
\\
\textbf{Teste realizado:} arquivo binário executável, com 74062 bytes.\\
\textbf{Binário de entrada:} não o colocaremos aqui por causa do seu tamanho\\
\textbf{Polinomio 1:} 0101010110110111\\
\textbf{Resultado do CRC:} 01011000 = 0x55B7 em hex\\
\\
\textbf{Teste realizado:} arquivo binário pdf, com 103763 bytes.\\
\textbf{Binário de entrada:} não o colocaremos aqui por causa do seu tamanho\\
\textbf{Polinomio 1:} 0101010110110111\\
\textbf{Resultado do CRC:} 01101000 = 0x68 em hex\\


\section{CONCLUSÃO}
\label{conclusao}

Apesar de encontrarmos diversas implementações do CRC na internet, optamos por construir uma que se adequasse ao conteúdo que vimos em sala de aula e o que está detalhado no livro "Redes de Computadores" \cite{tanenbaum}.

O algoritmo do CRC se mostrou eficiente para detecção de erros de trasmissão de dados, pois permite que sejam detectados 1 ou mais erros, inclusive em rajada, o que não é possível com outros algoritmos.
Além disso, ele se mostrou simples, o que reduz a complexidade de detecção de erros.

\bibliographystyle{sbc}
\bibliography{tp0}

\end{document}
